#!/usr/bin/env python3.8
"""
This module contains functions to build MI matrices and background correction (CLR) that can be used downstream to reconstruct the GRN..
Default results are in [nats] = natural log using np.log()
Written by Lior Shachaf 2021-02-09
"""

import numpy as np
from numpy import inf
import scipy.io
import pandas as pd
import Mutual_Info_based_binning_module as MI_binning_mod
import Mutual_Info_KNN_nats_module as MI_KNN_mod

def import_and_clean_input_file(input_file):
    """This function builds a 2D array of genes (Y-axis) and conditions (X-axis) based on expression data file generated by GeneNetWeaver.
    """
    in1 = open(input_file)
    in1_data = in1.readlines()
    in1.close()

    # Building array of genes (Y-axis) and conditions (X-axis)
    if "G1" in in1_data[0]: #Skips the header line
        print("G1!")
        in1_data.pop(0)
        
    in1_data_array = np.zeros((len(in1_data[0].split('\t')),len(in1_data)),dtype=float)

    for line_num,line in enumerate(in1_data):
        expression_data_tmp = line.split('\t')
        for gene_num,gene in enumerate(expression_data_tmp):
            in1_data_array[gene_num][line_num] = float(gene)

    #print(in1_data_array) ### Testing
    return in1_data_array

    
def calc_bins_num(data_size,binning_rule):
    if binning_rule == "Sturges":
        return int(np.ceil(np.log2(data_size)) + 1)
    elif binning_rule == "Sqrt":
        #return int(np.ceil(np.sqrt(data_size))) # used prior to Sep-24-2021
        return int(np.floor(np.sqrt(data_size))) # same as the R-package Minet
    elif "KNN" in binning_rule:
        return int(binning_rule.strip("KNN"))
        

def MI2_matrix_build(input_file_name,in1_data_array,bins_or_neighbors,mi_est):
    """The "heavy lifting" of building MI2 matrix by calc a half diagonal matrix and completing the other half"""
    MI2_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0]), dtype=float)

    if mi_est == "Shannon":
        dict_name = 'MI2_FB' + str(bins_or_neighbors) + '_Shan'
    elif mi_est == "Miller-Madow":
        dict_name = 'MI2_FB' + str(bins_or_neighbors) + '_MM'
    elif mi_est == "KSG":
        dict_name = 'MI2_KNN' + str(bins_or_neighbors) + '_' + mi_est
    elif mi_est == "KL":
        dict_name = 'MI2_KNN' + str(bins_or_neighbors) + '_' + mi_est

    # Determine the correct function to use to calculate MI2
    if mi_est == "Shannon" or mi_est == "Miller-Madow":
        MI2_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0]), dtype=float)
        bins_num = bins_or_neighbors
        
        for gene1 in range(in1_data_array.shape[0]):
            G0 = in1_data_array[gene1]
            Ex = MI_binning_mod.Entropy(G0,bins_num,mi_est)

            for gene2 in range(gene1,in1_data_array.shape[0]):
                #if gene2 == gene1:  ### comment if you need the self-information (entropy)
                 #   continue
                G1 = in1_data_array[gene2]
                Ey = MI_binning_mod.Entropy(G1,bins_num,mi_est)
                Exy = MI_binning_mod.Entropy2var(G0,G1,bins_num,mi_est)
                MI2_matrix[gene1,gene2] = MI_binning_mod.Two_way_info_from_entropy(Ex,Ey,Exy)
                # Completeng the half diagonal matrix
                MI2_matrix[gene2,gene1] = MI2_matrix[gene1,gene2]

    elif mi_est == "KSG":
        MI2_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0],bins_or_neighbors), dtype=float)
        for gene1 in range(in1_data_array.shape[0]):
            for gene2 in range(gene1,in1_data_array.shape[0]):
                #if gene2 == gene1:  ### comment if you need the self-information (entropy)
                 #   continue
                MI2_matrix[gene1,gene2,:] = MI_KNN_mod.MI_KNN_KDtree_algo(in1_data_array[gene1],in1_data_array[gene2],bins_or_neighbors)
                # Completeng the half diagonal matrix
                MI2_matrix[gene2,gene1,:] = MI2_matrix[gene1,gene2,:]

    elif mi_est == "KL":
        MI2_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0],bins_or_neighbors), dtype=float)
        for gene1 in range(in1_data_array.shape[0]):
            G0 = in1_data_array[gene1]
            Ex = MI_KNN_mod.Entropy_KNN_KDtree_algo(G0,bins_or_neighbors)
            for gene2 in range(gene1,in1_data_array.shape[0]):
                #if gene2 == gene1:  ### comment if you need the self-information (entropy)
                 #   continue
                G1 = in1_data_array[gene2]
                Ey = MI_KNN_mod.Entropy_KNN_KDtree_algo(G1,bins_or_neighbors)
                Exy = MI_KNN_mod.Entropy2D_KNN_KDtree_algo(G0,G1,bins_or_neighbors)

                MI2_matrix[gene1,gene2,:] = MI_KNN_mod.Two_way_info_from_entropy(Ex,Ey,Exy)
                # Completeng the half diagonal matrix
                MI2_matrix[gene2,gene1,:] = MI2_matrix[gene1,gene2,:]

    # Saving to a mat file
    matfile = input_file_name[:-4] + '_' + dict_name + '.mat'
    scipy.io.savemat(matfile, mdict={dict_name: MI2_matrix})

    print("done building MI2 matrix")
    
def TC_KSG_matrix_build(input_file_name,in1_data_array,bins_or_neighbors,mi_est):
    """The "heavy lifting" of TC calc but only for unique triplets (rest of the matrix is completed by symmetry). Note that negative values are not treated (not setting to zero)."""
    k_max = bins_or_neighbors
    TC_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0],in1_data_array.shape[0],k_max), dtype=float)

    for gene1 in range(in1_data_array.shape[0]):
        for gene2 in range(gene1,in1_data_array.shape[0]):
            if gene2 == gene1: ### comment if you need the self-information (entropy)
                continue
            for gene3 in range(gene2,in1_data_array.shape[0]):
                if gene3 == gene2 or gene3 == gene1: ### comment if you need the self-information (entropy)
                    continue

                G0 = in1_data_array[gene1]
                G1 = in1_data_array[gene2]
                G2 = in1_data_array[gene3]

                TC_matrix[gene1,gene2,gene3,:] = MI_KNN_mod.TC_KNN_KDtree_algo(G0,G1,G2,k_max)
                # Completing the 3d matrix
                TC_matrix[gene1,gene3,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene1,gene3] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene3,gene1] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene1,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene2,gene1] = TC_matrix[gene1,gene2,gene3]

    # Saving to a mat file        
    dict_name = 'TC_KNN' + str(bins_or_neighbors) + '_' + mi_est
    matfile = input_file_name[:-4] + '_' + dict_name + '.mat'
    scipy.io.savemat(matfile, mdict={dict_name: TC_matrix})

    print("done building TC matrix")

    
def TC_KL_matrix_build(input_file_name,in1_data_array,bins_or_neighbors,mi_est):
    ### The "heavy lifting" of MI and TC calc but only for unique triplets
    k_max = bins_or_neighbors
    TC_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0],in1_data_array.shape[0],k_max), dtype=float)

    for gene1 in range(in1_data_array.shape[0]):
        
        G0 = in1_data_array[gene1]
        Ex = MI_KNN_mod.Entropy_KNN_KDtree_algo(G0,k_max)

        for gene2 in range(gene1,in1_data_array.shape[0]):
            
            if gene2 == gene1: ### comment if you need the self-information (entropy)
                continue
            
            G1 = in1_data_array[gene2]
            Ey = MI_KNN_mod.Entropy_KNN_KDtree_algo(G1,k_max)
            
            for gene3 in range(gene2,in1_data_array.shape[0]):
                
                if gene3 == gene2 or gene3 == gene1: ### comment if you need the self-information (entropy)
                    continue

                G2 = in1_data_array[gene3]
                Ez = MI_KNN_mod.Entropy_KNN_KDtree_algo(G2,k_max)
                Exyz = MI_KNN_mod.Entropy3D_KNN_KDtree_algo(G0,G1,G2,k_max)

                TC_matrix[gene1,gene2,gene3] = MI_KNN_mod.Total_Corr_from_entropy(Ex,Ey,Ez,Exyz)

                # Completing the matrix: TC & II are symmetric while CMI & MI3 are semi => this can probably be more compact
                TC_matrix[gene2,gene1,gene3] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene1,gene3,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene1,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene3,gene1] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene2,gene1] = TC_matrix[gene1,gene2,gene3]

    # Replacing -inf and +inf values with zero => Booleam is faster than np.nan_to_num(MI2xy_matrix, copy=False, neginf=0) or MI2xy_matrix[np.isneginf(MI2xy_matrix)] = 0
    TC_matrix[TC_matrix == -inf] = 0; TC_matrix[TC_matrix == inf] = 0;

    # Saving to a mat file        
    dict_name = 'TC_KNN' + str(bins_or_neighbors) + '_' + mi_est
    matfile = input_file_name[:-4] + '_' + dict_name + '.mat'
    scipy.io.savemat(matfile, mdict={dict_name: TC_matrix})

    print("done building TC matrix")
 

def TC_FB_matrix_build(input_file_name,in1_data_array,bins_num,mi_est):
    ### The "heavy lifting" of MI and TC calc but only for unique triplets
    TC_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0],in1_data_array.shape[0]), dtype=float)

    for gene1 in range(in1_data_array.shape[0]):
        for gene2 in range(gene1,in1_data_array.shape[0]):
            if gene2 == gene1: ### comment if you need the self-information (entropy)
                continue
            for gene3 in range(gene2,in1_data_array.shape[0]):
                if gene3 == gene2 or gene3 == gene1: ### comment if you need the self-information (entropy)
                    continue

                G0 = in1_data_array[gene1]
                G1 = in1_data_array[gene2]
                G2 = in1_data_array[gene3]

                TC_matrix[gene1,gene2,gene3] = MI_binning_mod.Total_Corr(G0,G1,G2,bins_num,mi_est)
                # Completing the matrix
                TC_matrix[gene1,gene3,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene1,gene3] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene3,gene1] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene1,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene2,gene1] = TC_matrix[gene1,gene2,gene3]

    # Saving to a mat file
    if mi_est == "Shannon":
        dict_name = 'TC_FB' + str(bins_num) + '_Shan'
    elif mi_est == "Miller-Madow":
        dict_name = 'TC_FB' + str(bins_num) + '_MM'
    matfile = input_file_name[:-4] + '_' + dict_name + '.mat'
    scipy.io.savemat(matfile, mdict={dict_name: TC_matrix})

    print("done building TC matrix")


def TC_FB_matrix_build_from_entropies(input_file_name,in1_data_array,bins_num,mi_est):
    ### The "heavy lifting" of MI and TC calc but only for unique triplets
    TC_matrix = np.zeros((in1_data_array.shape[0],in1_data_array.shape[0],in1_data_array.shape[0]), dtype=float)

    for gene1 in range(in1_data_array.shape[0]):

        G0 = in1_data_array[gene1]
        Ex = MI_binning_mod.Entropy(G0,bins_num,mi_est)

        for gene2 in range(gene1,in1_data_array.shape[0]):

            if gene2 == gene1: ### comment if you need the self-information (entropy)
                continue

            G1 = in1_data_array[gene2]
            Ey = MI_binning_mod.Entropy(G1,bins_num,mi_est)

            for gene3 in range(gene2,in1_data_array.shape[0]):

                if gene3 == gene2 or gene3 == gene1: ### comment if you need the self-information (entropy)
                    continue

                G2 = in1_data_array[gene3]
                Ez = MI_binning_mod.Entropy(G2,bins_num,mi_est)
                Exyz = MI_binning_mod.Entropy3var(G0,G1,G2,bins_num,mi_est)

                TC_matrix[gene1,gene2,gene3] = MI_binning_mod.Total_Corr_from_entropy(Ex,Ey,Ez,Exyz)
                # Completing the matrix
                TC_matrix[gene1,gene3,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene1,gene3] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene2,gene3,gene1] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene1,gene2] = TC_matrix[gene1,gene2,gene3]
                TC_matrix[gene3,gene2,gene1] = TC_matrix[gene1,gene2,gene3]

    # Saving to a mat file
    if mi_est == "Shannon":
        dict_name = 'TC_FB' + str(bins_num) + '_Shan'
    elif mi_est == "Miller-Madow":
        dict_name = 'TC_FB' + str(bins_num) + '_MM'
    matfile = input_file_name[:-4] + '_' + dict_name + '.mat'
    scipy.io.savemat(matfile, mdict={dict_name: TC_matrix})

    print("done building TC matrix")
    
    
def building_DB_wMI2only(input_file_name,bins_num,mi_est):
    """Building DB file:
    # DB should include: X#, Y#, X-name, Y-name, MI(X,Y) 
    """
    ### Loading data files:
    #dict_name_MI2 = 'MI2_KNN' + str(bins_num) + '_KSG'
    dict_name_MI2 = input_file_name[:-4].split("all_")[1]  # Example: 'MI2_FB' + str(bins_num) + '_Shan'
    matdata1 = scipy.io.loadmat(input_file_name)
    MI2_matrix_tmp = matdata1[dict_name_MI2]
    #print(matfile,"file loaded")

    # Removing the k dimension from the mat file (4D) by saving to a new matrix with a specific k
    if mi_est == "KSG" or mi_est == "KL":
        MI2_matrix = MI2_matrix_tmp[:,:,bins_num-1]
    else:
        MI2_matrix = MI2_matrix_tmp
   
    ### writing to file with duplicate triplets to get all results
    if mi_est == "KSG":
        output_file = input_file_name[:-4].split("_MI2_KNN")[0]  + "_MI2_KNN" + str(bins_num) + "_KSG.dat"
    elif mi_est == "KL":
        output_file = input_file_name[:-4].split("_MI2_KNN")[0]  + "_MI2_KNN" + str(bins_num) + "_KL.dat"
    else:
        output_file = input_file_name[:-4] + ".dat"    

    out1 = open(output_file,"w")

    for i in range(MI2_matrix.shape[0]):
        for j in range(MI2_matrix.shape[1]):
            if i==j:
                continue             
            # DB should include: X#, Y#, X-name, Y-name, MI(X,Y) 
            out1.write("%2d,%2d,G%d,G%d,%2.9f\n" %(i,j,i,j,MI2_matrix[i,j]))

    out1.close()

    print("done writing to file",output_file)
    return [MI2_matrix]  


def building_DB_wMI2only_backup(input_file_name,bins_num,mi_est):
    """Building DB file:
    # DB should include: X#, Y#, X-name, Y-name, MI(X,Y) 
    """
    ### Loading data files:
    if mi_est == "Shannon":
        dict_name_MI2 = 'MI2_FB' + str(bins_num) + '_Shan'
    elif mi_est == "Miller-Madow":
        dict_name_MI2 = 'MI2_FB' + str(bins_num) + '_MM'
    elif mi_est == "KSG":
        dict_name_MI2 = 'MI2_KNN' + str(bins_num) + '_KSG'
        
    matfile1 = input_file_name[:-4] + '_' + dict_name_MI2 + '.mat'
    matdata1 = scipy.io.loadmat(matfile1)
    MI2_matrix_tmp = matdata1[dict_name_MI2]
    #print(matfile,"file loaded")

    # Removing the k dimension from the mat file (4D) by saving to a new matrix with a specific k
    if mi_est == "KSG":
        MI2_matrix = MI2_matrix_tmp[:,:,bins_num-1]
    else:
        MI2_matrix = MI2_matrix_tmp
   
    ### writing to file with duplicate triplets to get all results for the asymmetric MI3 and CMI
    if mi_est == "Shannon":
        output_file = input_file_name[:-4] + "_MI2_FB" + str(bins_num) + "_Shan.dat"
    elif mi_est == "Miller-Madow":
        output_file = input_file_name[:-4] + "_MI2_FB" + str(bins_num) + "_MM.dat"
    elif mi_est == "KSG":
        output_file = input_file_name[:-4] + "_MI2_KNN" + str(bins_num) + "_KSG.dat"    

    out1 = open(output_file,"w")

    for i in range(MI2_matrix.shape[0]):
        for j in range(MI2_matrix.shape[1]):
            if i==j:
                continue             
            # DB should include: X#, Y#, X-name, Y-name, MI(X,Y) 
            out1.write("%2d,%2d,G%d,G%d,%2.9f\n" %(i,j,i,j,MI2_matrix[i,j]))

    out1.close()

    print("done writing to file",output_file)
    return [MI2_matrix]  
    
    
def building_DB_wMI2andTC(input_file_name,bins_num,mi_est):
    """Building DB file:
    # DB should include: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI(X,Z), MI(Y,Z), TC 
    input_file_name example = file[:-4] + "_TC_" + mi_est_string + ".mat" (wherefile = topology + "_" + expression_data_type + "_all.tsv") 
    """
    ### Loading data files: (MI2 and TC need to have the same k)      
    dict_name_MI2 = input_file_name[:-4].split("all_")[1].replace("TC","MI2")  # Example: 'MI2_FB' + str(bins_num) + '_Shan'
    matdata1 = scipy.io.loadmat(input_file_name.replace("TC","MI2"))
    MI2_matrix_tmp = matdata1[dict_name_MI2]
    
    dict_name_TC  = input_file_name[:-4].split("all_")[1]  # Example:'TC_FB'+str(bins_num)+'_Shan'
    matdata2 = scipy.io.loadmat(input_file_name)
    TC_matrix_tmp = matdata2[dict_name_TC]

    # Removing the k dimension from the mat file (4D) by saving to a new matrix with a specific k
    if mi_est == "KSG" or mi_est == "KL":
        MI2_matrix = MI2_matrix_tmp[:,:,bins_num-1]
        TC_matrix = TC_matrix_tmp[:,:,:,bins_num-1]
    else:
        MI2_matrix = MI2_matrix_tmp
        TC_matrix = TC_matrix_tmp
   
    ### writing to file with duplicate triplets to get all results for the asymmetric MI3 and CMI
    if mi_est == "KSG":
        output_file = input_file_name[:-4].split("_TC_KNN")[0]  + "_MI2andTC_KNN" + str(bins_num) + "_KSG.dat"
    elif mi_est == "KL":
        output_file = input_file_name[:-4].split("_TC_KNN")[0]  + "_MI2andTC_KNN" + str(bins_num) + "_KL.dat"
    else:
        output_file = input_file_name[:-4].replace("TC","MI2andTC") + ".dat"
        ### old ver: 
        #output_file = input_file_name[:-4] + "_MI_KNN" + str(bins_num) + "_KSG_triplets_calc_v3.dat"    

    out1 = open(output_file,"w")

    for i in range(TC_matrix.shape[0]):
        for j in range(TC_matrix.shape[1]):
            if i==j:
                continue
            for m in range(TC_matrix.shape[2]):
                if m==i or m==j:
                    continue                
                # DB should include: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI(X,Z), MI(Y,Z), TC
                out1.write("%2d,%2d,%2d,G%d,G%d,G%d,%2.9f,%2.9f,%2.9f,%2.9f\n" %(i,j,m,i,j,m,MI2_matrix[i,j],MI2_matrix[i,m],MI2_matrix[j,m],TC_matrix[i,j,m]))

    out1.close()

    print("done writing to file",output_file)
    return [MI2_matrix,TC_matrix]    
    
    
def building_DB_wAll_MI(input_file_name,bins_num,mi_est):
    """Building DB file:
    # TC
    # MI3((X,Y);Z) = TC – MI(X,Y)
    # II(XYZ) = TC – MI(X,Y) – MI(X,Z) – MI(Y,Z) 
    # CMI(X;Y|Z) = TC – MI(X,Z) – MI(Y,Z) 

    # DB should include: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI(X,Z), MI(Y,Z), TC, II(XYZ), MI3((X,Y);Z), MI3((Z,X);Y), MI3((Y,Z);X), CMI(X;Y|Z), CMI(Z;X|Y), CMI(Y;Z|X) 
    """
    ### Loading data files:
    if mi_est == "Shannon":
        dict_name_MI2 = 'MI2_FB' + str(bins_num) + '_Shan'
        dict_name_TC = 'TC_FB' + str(bins_num) + '_Shan'
    elif mi_est == "Miller-Madow":
        dict_name_MI2 = 'MI2_FB' + str(bins_num) + '_MM'
        dict_name_TC = 'TC_FB' + str(bins_num) + '_MM'
    elif mi_est == "KSG":
        dict_name_MI2 = 'MI2_KNN' + str(bins_num) + '_KSG'
        dict_name_TC = 'TC_KNN' + str(bins_num) + '_KSG'
        
    matfile1 = input_file_name[:-4] + '_' + dict_name_MI2 + '.mat'
    matdata1 = scipy.io.loadmat(matfile1)
    MI2_matrix_tmp = matdata1[dict_name_MI2]
    #print(matfile,"file loaded")

    matfile2 = input_file_name[:-4] + '_' + dict_name_TC + '.mat'
    matdata2 = scipy.io.loadmat(matfile2)
    TC_matrix_tmp = matdata2[dict_name_TC]
    #print(matfile,"file loaded")

    # Removing the k dimension from the mat file (4D) by saving to a new matrix with a specific k
    if mi_est == "KSG":
        MI2_matrix = MI2_matrix_tmp[:,:,bins_num-1]
        TC_matrix = TC_matrix_tmp[:,:,:,bins_num-1]
    else:
        MI2_matrix = MI2_matrix_tmp
        TC_matrix = TC_matrix_tmp
   
    ### New arrays to calc. MI3, CMI, and II
    MI3_matrix=np.zeros(TC_matrix.shape, dtype=float)
    II_matrix=np.zeros(TC_matrix.shape, dtype=float)
    CMI_matrix=np.zeros(TC_matrix.shape, dtype=float)

    for i in range(TC_matrix.shape[0]):
        for j in range(TC_matrix.shape[1]):
            #if i==j: ### comment if you need the self-information (entropy)
             #   continue
            for m in range(TC_matrix.shape[2]):
                #if m==i or m==j: ### comment if you need the self-information (entropy)
                 #   continue
                MI3_matrix[i,j,m] = TC_matrix[i,j,m] - MI2_matrix[i,j]   
                II_matrix[i,j,m] = TC_matrix[i,j,m] - MI2_matrix[i,j] - MI2_matrix[i,m] - MI2_matrix[j,m]   
                CMI_matrix[i,j,m] = TC_matrix[i,j,m] - MI2_matrix[i,m] - MI2_matrix[j,m]
    """ # For testing purpose:
    print("MI2_min=",np.min(MI2_matrix[:,:]),"MI2_max=",np.max(MI2_matrix[:,:]))
    print("TC_min=",np.min(TC_matrix[:,:,:]),"TC_max=",np.max(TC_matrix[:,:,:]))
    print("MI3_min=",np.min(MI3_matrix[:,:,:]),"MI3_max=",np.max(MI3_matrix[:,:,:]))
    print("II_min=",np.min(II_matrix[:,:,:]),"II_max=",np.max(II_matrix[:,:,:]))
    print("CMI_min=",np.min(CMI_matrix[:,:,:]),"CMI_max=",np.max(CMI_matrix[:,:,:]))
    """
    ### writing to file with duplicate triplets to get all results for the asymmetric MI3 and CMI
    if mi_est == "Shannon":
        output_file = input_file_name[:-4] + "_MI_FB" + str(bins_num) + "_Shan_triplets_calc_v3.dat"
    elif mi_est == "Miller-Madow":
        output_file = input_file_name[:-4] + "_MI_FB" + str(bins_num) + "_MM_triplets_calc_v3.dat"
    elif mi_est == "KSG":
        output_file = input_file_name[:-4] + "_MI_KNN" + str(bins_num) + "_KSG_triplets_calc_v3.dat"    

    out1 = open(output_file,"w")

    for i in range(TC_matrix.shape[0]):
        for j in range(TC_matrix.shape[1]):
            if i==j:
                continue
            for m in range(TC_matrix.shape[2]):
                if m==i or m==j:
                    continue                
                # DB should include: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI(X,Z), MI(Y,Z), TC, II(XYZ), MI3((X,Y);Z), MI3((Z,X);Y), MI3((Y,Z);X), CMI(X;Y|Z), CMI(Z;X|Y), CMI(Y;Z|X) 
                out1.write("%2d,%2d,%2d,G%d,G%d,G%d,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f,%2.9f\n" %(i,j,m,i,j,m,MI2_matrix[i,j],MI2_matrix[i,m],MI2_matrix[j,m],TC_matrix[i,j,m],II_matrix[i,j,m],MI3_matrix[i,j,m],MI3_matrix[m,i,j],MI3_matrix[j,m,i],CMI_matrix[i,j,m],CMI_matrix[m,i,j],CMI_matrix[j,m,i]))

    out1.close()

    print("done writing to file",output_file)
    return [MI2_matrix,TC_matrix,II_matrix,MI3_matrix,CMI_matrix]


def building_DB_wAll_MI_FB(input_file_name,bins_num,mi_est):
    """Backward compatibility function. Same as building_DB_wAll_MI"""
    [MI2_matrix,TC_matrix,II_matrix,MI3_matrix,CMI_matrix] = building_DB_wAll_MI(input_file_name,bins_num,mi_est)
    return [MI2_matrix,TC_matrix,II_matrix,MI3_matrix,CMI_matrix]


### Functions for CLR
def CLR_BG_calc(file,bins_or_neighbors,mi_est,network_size):
    """ This function calculates the mean and variance for each gene and replaces the following Unix bash script:
    for g1 in `seq 0 $(($max_genes-1))`;
    do
    #echo G$g1 # Test
    grep -w "G$g1" $filename_MI_table | awk -v g11="G$g1" -F, '{ for(i=7;i<=NF;i++) {total[i]+=$i ; sq[i]+=$i*$i ; } }
    END {
       printf "%3s,", g11 ;
       for(i=7;i<=NF;i++) printf "%9f,%9f,", total[i]/NR, sq[i]/NR-(total[i]/NR)**2 ;
       printf "\n" ;
    }' >> MI_mean_and_variance_1gene_v3.tmp
    
    done
    
    cut -d"," -f 1-3,8-13,18-19 MI_mean_and_variance_1gene_v3.tmp > $output_filename
    """
    if mi_est == "Shannon":
        filename_MI_table = file + "_MI_FB" + bins_or_neighbors + "_Shan_triplets_calc_v3.dat"
        output_filename="MI_FB" + bins_or_neighbors + "_Shan_mean_and_variance_v3.dat"
    elif mi_est == "Miller-Madow":
        filename_MI_table = file + "_MI_FB" + bins_or_neighbors + "_MM_triplets_calc_v3.dat"
        output_filename="MI_FB" + bins_or_neighbors + "_MM_mean_and_variance_v3.dat"
    elif mi_est == "KSG":
        filename_MI_table = file + "_MI_KNN" + bins_or_neighbors + "_KSG_triplets_calc_v3.dat"
        output_filename="MI_KNN" + bins_or_neighbors + "_KSG_mean_and_variance_v3.dat"
    elif mi_est == "KL":
        filename_MI_table = file + "_MI_KNN" + bins_or_neighbors + "_KL_triplets_calc_v3.dat"
        output_filename="MI_KNN" + bins_or_neighbors + "_KL_mean_and_variance_v3.dat"
                
    column_names = ['X','Y','Z','Gene X', 'Gene Y', 'Gene Z', 'MI(X;Y)', 'MI(X;Z)', 'MI(Y;Z)', 'TC', 'II(XYZ)', 'MI3((X,Y);Z)', 'MI3((Z,X);Y)', 'MI3((Y,Z);X)', 'CMI(X;Y|Z)', 'CMI(Z;X|Y)', 'CMI(Y;Z|X)']

    df = pd.read_csv(filename_MI_table, comment='#', names=column_names)
    
    # open file for writing
    out1 = open(output_filename,"w")
    
    for gene_index in range(network_size):
        
        df_filtered = df[((df['X'] == gene_index) | (df['Y'] == gene_index) | (df['Z'] == gene_index))]
        # Dropping column with genes number and names as well as redundant MI, MI3, CMI 
        df_filtered.drop(df.columns[[0, 1, 2, 3, 4, 5, 7, 8, 12, 13, 15, 16]], axis=1, inplace = True)  # df.columns is zero-based pd.Index 
        
        mean_list = df_filtered.mean(axis=0).tolist()
        var_list = df_filtered.var(axis=0).tolist()
        
        out1.write("%3s" %("G"+str(gene_index)))
        
        for item in zip(mean_list,var_list):
            out1.write(",%2.9f,%2.9f" %item)
            
        out1.write("\n")
            
    out1.close()   


def z_score_doublet(value,mean1,var1,mean2,var2):
    return ( (value-mean1)**2/var1 + (value-mean2)**2/var2 )**(1/2)


def z_score_triplet(value,mean1,var1,mean2,var2,mean3,var3):
    return ( (value-mean1)**2/var1 + (value-mean2)**2/var2 + (value-mean3)**2/var3 )**(1/2)


def MI_analysis_wCLR_BG(input_file_name,bins_num,mi_est,MI2_matrix,TC_matrix,II_matrix,MI3_matrix,CMI_matrix):
    """ calculating z-score for each triplet: f = sqrt((z_1)**2+(z_2)**2+(z_3)**2)"""
    
    # Setting some constants and lists
    MI2_mean_idx = 1; MI2_var_idx = 2;
    TC_mean_idx = 3; TC_var_idx = 4;
    II_mean_idx = 5; II_var_idx = 6;
    MI3_mean_idx = 7; MI3_var_idx = 8;
    CMI_mean_idx = 9; CMI_var_idx = 10;
    means_list = [MI2_mean_idx,MI2_mean_idx,MI2_mean_idx,TC_mean_idx,II_mean_idx,MI3_mean_idx,MI3_mean_idx,MI3_mean_idx,CMI_mean_idx,CMI_mean_idx,CMI_mean_idx];
    vars_list=[MI2_var_idx,MI2_var_idx,MI2_var_idx,TC_var_idx,II_var_idx,MI3_var_idx,MI3_var_idx,MI3_var_idx,CMI_var_idx,CMI_var_idx,CMI_var_idx]

    ### Preparing file names for loading data file and ourput file
    if mi_est == "Shannon":
        mean_and_variance_inputfile = "MI_FB" + str(bins_num) + "_Shan_mean_and_variance_v3.dat"
        output_file2 = input_file_name[:-4] + "_MI_FB" + str(bins_num) + "_Shan_triplets_calc_v3_with_Zscore_v3.dat"
    elif mi_est == "Miller-Madow":
        mean_and_variance_inputfile = "MI_FB" + str(bins_num) + "_MM_mean_and_variance_v3.dat"
        output_file2 = input_file_name[:-4] + "_MI_FB" + str(bins_num) + "_MM_triplets_calc_v3_with_Zscore_v3.dat"
    elif mi_est == "KSG":
        mean_and_variance_inputfile = "MI_KNN" + str(bins_num) + "_KSG_mean_and_variance_v3.dat"
        output_file2 = input_file_name[:-4] + "_MI_KNN" + str(bins_num) + "_KSG_triplets_calc_v3_with_Zscore_v3.dat"
    
    ### Loading mean and variance data for Z-score calc
    mean_and_variance_1gene = np.loadtxt(mean_and_variance_inputfile,delimiter=',',dtype='str,float,float,float,float,float,float,float,float,float,float')
    print("done file mean_and_variance_1gene",mean_and_variance_1gene[0])
    
    ### output file
    out1 = open(output_file2,"w")
    
    # if we want to write all permutations for each triplet
    """
    for i in range(TC_matrix.shape[0]):
        for j in range(TC_matrix.shape[1]):
            if i==j:
                continue
            for m in range(TC_matrix.shape[2]):
                    if m==i or m==j:
                        continue  
                    """
    # if we want to write only one permutations for each triplet
    for i in range(TC_matrix.shape[0]-2): #range(start,finish-2):
            for j in range(i+1,TC_matrix.shape[1]-1): #range(i+1,finish-1):
                for m in range(j+1,TC_matrix.shape[2]): #range(j+1,finish):
                    z_scores_list=[]
                    counter = 0
                    TC_etc_list = [MI2_matrix[i,j],MI2_matrix[i,m],MI2_matrix[j,m],TC_matrix[i,j,m],II_matrix[i,j,m],MI3_matrix[i,j,m],MI3_matrix[m,i,j],MI3_matrix[j,m,i],CMI_matrix[i,j,m],CMI_matrix[m,i,j],CMI_matrix[j,m,i]]

                    out1.write("%2d,%2d,%2d,G%d,G%d,G%d" %(i,j,m,i,j,m))

                    for value,MI_mean_idx,MI_var_idx in zip(TC_etc_list,means_list,vars_list):
                        mean1 = mean_and_variance_1gene[i][MI_mean_idx]
                        var1 = mean_and_variance_1gene[i][MI_var_idx]
                        mean2 = mean_and_variance_1gene[j][MI_mean_idx]
                        var2 = mean_and_variance_1gene[j][MI_var_idx]
                        mean3 = mean_and_variance_1gene[m][MI_mean_idx]
                        var3 = mean_and_variance_1gene[m][MI_var_idx]
                        if counter == 0:
                            z_scores_list.append(z_score_doublet(value,mean1,var1,mean2,var2))
                        elif counter == 1:
                            z_scores_list.append(z_score_doublet(value,mean1,var1,mean3,var3))
                        elif counter == 2:
                            z_scores_list.append(z_score_doublet(value,mean2,var2,mean3,var3))
                        else:
                            z_scores_list.append(z_score_triplet(value,mean1,var1,mean2,var2,mean3,var3))

                        counter+=1
                        out1.write(",%2.9f,%2.9f" %(value, z_scores_list[-1]))
                    # DB should include: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI2-z-score, MI(X,Z), MI2-z-score, MI(Y,Z), MI2-z-score, TC, TC-z-score, II(XYZ), II-z-score, MI3((X,Y);Z), MI3-z-score, MI3((Z,X);Y), z-score, MI3((Y,Z);X), z-score, CMI(X;Y|Z), CMI-z-score, CMI(Z;X|Y), z-score,  CMI(Y;Z|X) , z-score  
                    out1.write("\n")

    print("done writing to file",output_file2)

    out1.close()


def MI_FB_analysis_wCLR_BG(input_file_name,bins_num,mi_est,MI2_matrix,TC_matrix,II_matrix,MI3_matrix,CMI_matrix):
    """Backward compatibility function. Same as MI_analysis_wCLR_BG"""
    MI_analysis_wCLR_BG(input_file_name,bins_num,mi_est,MI2_matrix,TC_matrix,II_matrix,MI3_matrix,CMI_matrix)
